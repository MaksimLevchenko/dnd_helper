// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'spells_data.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SpellsData _$SpellsDataFromJson(Map<String, dynamic> json) {
  return _SpellsData.fromJson(json);
}

/// @nodoc
mixin _$SpellsData {
  String get name => throw _privateConstructorUsedError;
  int? get level => throw _privateConstructorUsedError;
  MagicScools? get school => throw _privateConstructorUsedError;
  bool? get isVerbal => throw _privateConstructorUsedError;
  bool? get isSomatic => throw _privateConstructorUsedError;
  bool? get isMaterial => throw _privateConstructorUsedError;
  String? get materialComponents => throw _privateConstructorUsedError;
  int? get castingTime => throw _privateConstructorUsedError;
  CastingResource? get castingResource => throw _privateConstructorUsedError;
  int? get castingResourceCost => throw _privateConstructorUsedError;
  String? get castingConditions => throw _privateConstructorUsedError;
  TargetOrAreaType? get targetAndAreaType => throw _privateConstructorUsedError;
  AreaSizeUnits? get areaSizeUnits => throw _privateConstructorUsedError;
  int? get area => throw _privateConstructorUsedError;
  DistanceType? get distanceType => throw _privateConstructorUsedError;
  int? get distance => throw _privateConstructorUsedError;
  DurationType? get durationType => throw _privateConstructorUsedError;
  int? get duration => throw _privateConstructorUsedError;
  ActionType? get actionType => throw _privateConstructorUsedError;
  Attributes? get savingThrow => throw _privateConstructorUsedError;
  String? get damage => throw _privateConstructorUsedError;
  DamageTypes? get damageType => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  ClassData? get classes => throw _privateConstructorUsedError;
  String? get subClasses => throw _privateConstructorUsedError;
  String? get source => throw _privateConstructorUsedError;

  /// Serializes this SpellsData to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SpellsDataCopyWith<SpellsData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpellsDataCopyWith<$Res> {
  factory $SpellsDataCopyWith(
          SpellsData value, $Res Function(SpellsData) then) =
      _$SpellsDataCopyWithImpl<$Res, SpellsData>;
  @useResult
  $Res call(
      {String name,
      int? level,
      MagicScools? school,
      bool? isVerbal,
      bool? isSomatic,
      bool? isMaterial,
      String? materialComponents,
      int? castingTime,
      CastingResource? castingResource,
      int? castingResourceCost,
      String? castingConditions,
      TargetOrAreaType? targetAndAreaType,
      AreaSizeUnits? areaSizeUnits,
      int? area,
      DistanceType? distanceType,
      int? distance,
      DurationType? durationType,
      int? duration,
      ActionType? actionType,
      Attributes? savingThrow,
      String? damage,
      DamageTypes? damageType,
      String? description,
      ClassData? classes,
      String? subClasses,
      String? source});

  $ClassDataCopyWith<$Res>? get classes;
}

/// @nodoc
class _$SpellsDataCopyWithImpl<$Res, $Val extends SpellsData>
    implements $SpellsDataCopyWith<$Res> {
  _$SpellsDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? level = freezed,
    Object? school = freezed,
    Object? isVerbal = freezed,
    Object? isSomatic = freezed,
    Object? isMaterial = freezed,
    Object? materialComponents = freezed,
    Object? castingTime = freezed,
    Object? castingResource = freezed,
    Object? castingResourceCost = freezed,
    Object? castingConditions = freezed,
    Object? targetAndAreaType = freezed,
    Object? areaSizeUnits = freezed,
    Object? area = freezed,
    Object? distanceType = freezed,
    Object? distance = freezed,
    Object? durationType = freezed,
    Object? duration = freezed,
    Object? actionType = freezed,
    Object? savingThrow = freezed,
    Object? damage = freezed,
    Object? damageType = freezed,
    Object? description = freezed,
    Object? classes = freezed,
    Object? subClasses = freezed,
    Object? source = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      level: freezed == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int?,
      school: freezed == school
          ? _value.school
          : school // ignore: cast_nullable_to_non_nullable
              as MagicScools?,
      isVerbal: freezed == isVerbal
          ? _value.isVerbal
          : isVerbal // ignore: cast_nullable_to_non_nullable
              as bool?,
      isSomatic: freezed == isSomatic
          ? _value.isSomatic
          : isSomatic // ignore: cast_nullable_to_non_nullable
              as bool?,
      isMaterial: freezed == isMaterial
          ? _value.isMaterial
          : isMaterial // ignore: cast_nullable_to_non_nullable
              as bool?,
      materialComponents: freezed == materialComponents
          ? _value.materialComponents
          : materialComponents // ignore: cast_nullable_to_non_nullable
              as String?,
      castingTime: freezed == castingTime
          ? _value.castingTime
          : castingTime // ignore: cast_nullable_to_non_nullable
              as int?,
      castingResource: freezed == castingResource
          ? _value.castingResource
          : castingResource // ignore: cast_nullable_to_non_nullable
              as CastingResource?,
      castingResourceCost: freezed == castingResourceCost
          ? _value.castingResourceCost
          : castingResourceCost // ignore: cast_nullable_to_non_nullable
              as int?,
      castingConditions: freezed == castingConditions
          ? _value.castingConditions
          : castingConditions // ignore: cast_nullable_to_non_nullable
              as String?,
      targetAndAreaType: freezed == targetAndAreaType
          ? _value.targetAndAreaType
          : targetAndAreaType // ignore: cast_nullable_to_non_nullable
              as TargetOrAreaType?,
      areaSizeUnits: freezed == areaSizeUnits
          ? _value.areaSizeUnits
          : areaSizeUnits // ignore: cast_nullable_to_non_nullable
              as AreaSizeUnits?,
      area: freezed == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as int?,
      distanceType: freezed == distanceType
          ? _value.distanceType
          : distanceType // ignore: cast_nullable_to_non_nullable
              as DistanceType?,
      distance: freezed == distance
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as int?,
      durationType: freezed == durationType
          ? _value.durationType
          : durationType // ignore: cast_nullable_to_non_nullable
              as DurationType?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int?,
      actionType: freezed == actionType
          ? _value.actionType
          : actionType // ignore: cast_nullable_to_non_nullable
              as ActionType?,
      savingThrow: freezed == savingThrow
          ? _value.savingThrow
          : savingThrow // ignore: cast_nullable_to_non_nullable
              as Attributes?,
      damage: freezed == damage
          ? _value.damage
          : damage // ignore: cast_nullable_to_non_nullable
              as String?,
      damageType: freezed == damageType
          ? _value.damageType
          : damageType // ignore: cast_nullable_to_non_nullable
              as DamageTypes?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      classes: freezed == classes
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as ClassData?,
      subClasses: freezed == subClasses
          ? _value.subClasses
          : subClasses // ignore: cast_nullable_to_non_nullable
              as String?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ClassDataCopyWith<$Res>? get classes {
    if (_value.classes == null) {
      return null;
    }

    return $ClassDataCopyWith<$Res>(_value.classes!, (value) {
      return _then(_value.copyWith(classes: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SpellsDataImplCopyWith<$Res>
    implements $SpellsDataCopyWith<$Res> {
  factory _$$SpellsDataImplCopyWith(
          _$SpellsDataImpl value, $Res Function(_$SpellsDataImpl) then) =
      __$$SpellsDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      int? level,
      MagicScools? school,
      bool? isVerbal,
      bool? isSomatic,
      bool? isMaterial,
      String? materialComponents,
      int? castingTime,
      CastingResource? castingResource,
      int? castingResourceCost,
      String? castingConditions,
      TargetOrAreaType? targetAndAreaType,
      AreaSizeUnits? areaSizeUnits,
      int? area,
      DistanceType? distanceType,
      int? distance,
      DurationType? durationType,
      int? duration,
      ActionType? actionType,
      Attributes? savingThrow,
      String? damage,
      DamageTypes? damageType,
      String? description,
      ClassData? classes,
      String? subClasses,
      String? source});

  @override
  $ClassDataCopyWith<$Res>? get classes;
}

/// @nodoc
class __$$SpellsDataImplCopyWithImpl<$Res>
    extends _$SpellsDataCopyWithImpl<$Res, _$SpellsDataImpl>
    implements _$$SpellsDataImplCopyWith<$Res> {
  __$$SpellsDataImplCopyWithImpl(
      _$SpellsDataImpl _value, $Res Function(_$SpellsDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? level = freezed,
    Object? school = freezed,
    Object? isVerbal = freezed,
    Object? isSomatic = freezed,
    Object? isMaterial = freezed,
    Object? materialComponents = freezed,
    Object? castingTime = freezed,
    Object? castingResource = freezed,
    Object? castingResourceCost = freezed,
    Object? castingConditions = freezed,
    Object? targetAndAreaType = freezed,
    Object? areaSizeUnits = freezed,
    Object? area = freezed,
    Object? distanceType = freezed,
    Object? distance = freezed,
    Object? durationType = freezed,
    Object? duration = freezed,
    Object? actionType = freezed,
    Object? savingThrow = freezed,
    Object? damage = freezed,
    Object? damageType = freezed,
    Object? description = freezed,
    Object? classes = freezed,
    Object? subClasses = freezed,
    Object? source = freezed,
  }) {
    return _then(_$SpellsDataImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      level: freezed == level
          ? _value.level
          : level // ignore: cast_nullable_to_non_nullable
              as int?,
      school: freezed == school
          ? _value.school
          : school // ignore: cast_nullable_to_non_nullable
              as MagicScools?,
      isVerbal: freezed == isVerbal
          ? _value.isVerbal
          : isVerbal // ignore: cast_nullable_to_non_nullable
              as bool?,
      isSomatic: freezed == isSomatic
          ? _value.isSomatic
          : isSomatic // ignore: cast_nullable_to_non_nullable
              as bool?,
      isMaterial: freezed == isMaterial
          ? _value.isMaterial
          : isMaterial // ignore: cast_nullable_to_non_nullable
              as bool?,
      materialComponents: freezed == materialComponents
          ? _value.materialComponents
          : materialComponents // ignore: cast_nullable_to_non_nullable
              as String?,
      castingTime: freezed == castingTime
          ? _value.castingTime
          : castingTime // ignore: cast_nullable_to_non_nullable
              as int?,
      castingResource: freezed == castingResource
          ? _value.castingResource
          : castingResource // ignore: cast_nullable_to_non_nullable
              as CastingResource?,
      castingResourceCost: freezed == castingResourceCost
          ? _value.castingResourceCost
          : castingResourceCost // ignore: cast_nullable_to_non_nullable
              as int?,
      castingConditions: freezed == castingConditions
          ? _value.castingConditions
          : castingConditions // ignore: cast_nullable_to_non_nullable
              as String?,
      targetAndAreaType: freezed == targetAndAreaType
          ? _value.targetAndAreaType
          : targetAndAreaType // ignore: cast_nullable_to_non_nullable
              as TargetOrAreaType?,
      areaSizeUnits: freezed == areaSizeUnits
          ? _value.areaSizeUnits
          : areaSizeUnits // ignore: cast_nullable_to_non_nullable
              as AreaSizeUnits?,
      area: freezed == area
          ? _value.area
          : area // ignore: cast_nullable_to_non_nullable
              as int?,
      distanceType: freezed == distanceType
          ? _value.distanceType
          : distanceType // ignore: cast_nullable_to_non_nullable
              as DistanceType?,
      distance: freezed == distance
          ? _value.distance
          : distance // ignore: cast_nullable_to_non_nullable
              as int?,
      durationType: freezed == durationType
          ? _value.durationType
          : durationType // ignore: cast_nullable_to_non_nullable
              as DurationType?,
      duration: freezed == duration
          ? _value.duration
          : duration // ignore: cast_nullable_to_non_nullable
              as int?,
      actionType: freezed == actionType
          ? _value.actionType
          : actionType // ignore: cast_nullable_to_non_nullable
              as ActionType?,
      savingThrow: freezed == savingThrow
          ? _value.savingThrow
          : savingThrow // ignore: cast_nullable_to_non_nullable
              as Attributes?,
      damage: freezed == damage
          ? _value.damage
          : damage // ignore: cast_nullable_to_non_nullable
              as String?,
      damageType: freezed == damageType
          ? _value.damageType
          : damageType // ignore: cast_nullable_to_non_nullable
              as DamageTypes?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      classes: freezed == classes
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as ClassData?,
      subClasses: freezed == subClasses
          ? _value.subClasses
          : subClasses // ignore: cast_nullable_to_non_nullable
              as String?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SpellsDataImpl implements _SpellsData {
  const _$SpellsDataImpl(
      {this.name = 'name',
      this.level,
      this.school,
      this.isVerbal,
      this.isSomatic,
      this.isMaterial,
      this.materialComponents,
      this.castingTime,
      this.castingResource,
      this.castingResourceCost,
      this.castingConditions,
      this.targetAndAreaType,
      this.areaSizeUnits,
      this.area,
      this.distanceType,
      this.distance,
      this.durationType,
      this.duration,
      this.actionType,
      this.savingThrow,
      this.damage,
      this.damageType,
      this.description,
      this.classes,
      this.subClasses,
      this.source});

  factory _$SpellsDataImpl.fromJson(Map<String, dynamic> json) =>
      _$$SpellsDataImplFromJson(json);

  @override
  @JsonKey()
  final String name;
  @override
  final int? level;
  @override
  final MagicScools? school;
  @override
  final bool? isVerbal;
  @override
  final bool? isSomatic;
  @override
  final bool? isMaterial;
  @override
  final String? materialComponents;
  @override
  final int? castingTime;
  @override
  final CastingResource? castingResource;
  @override
  final int? castingResourceCost;
  @override
  final String? castingConditions;
  @override
  final TargetOrAreaType? targetAndAreaType;
  @override
  final AreaSizeUnits? areaSizeUnits;
  @override
  final int? area;
  @override
  final DistanceType? distanceType;
  @override
  final int? distance;
  @override
  final DurationType? durationType;
  @override
  final int? duration;
  @override
  final ActionType? actionType;
  @override
  final Attributes? savingThrow;
  @override
  final String? damage;
  @override
  final DamageTypes? damageType;
  @override
  final String? description;
  @override
  final ClassData? classes;
  @override
  final String? subClasses;
  @override
  final String? source;

  @override
  String toString() {
    return 'SpellsData(name: $name, level: $level, school: $school, isVerbal: $isVerbal, isSomatic: $isSomatic, isMaterial: $isMaterial, materialComponents: $materialComponents, castingTime: $castingTime, castingResource: $castingResource, castingResourceCost: $castingResourceCost, castingConditions: $castingConditions, targetAndAreaType: $targetAndAreaType, areaSizeUnits: $areaSizeUnits, area: $area, distanceType: $distanceType, distance: $distance, durationType: $durationType, duration: $duration, actionType: $actionType, savingThrow: $savingThrow, damage: $damage, damageType: $damageType, description: $description, classes: $classes, subClasses: $subClasses, source: $source)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpellsDataImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.level, level) || other.level == level) &&
            (identical(other.school, school) || other.school == school) &&
            (identical(other.isVerbal, isVerbal) ||
                other.isVerbal == isVerbal) &&
            (identical(other.isSomatic, isSomatic) ||
                other.isSomatic == isSomatic) &&
            (identical(other.isMaterial, isMaterial) ||
                other.isMaterial == isMaterial) &&
            (identical(other.materialComponents, materialComponents) ||
                other.materialComponents == materialComponents) &&
            (identical(other.castingTime, castingTime) ||
                other.castingTime == castingTime) &&
            (identical(other.castingResource, castingResource) ||
                other.castingResource == castingResource) &&
            (identical(other.castingResourceCost, castingResourceCost) ||
                other.castingResourceCost == castingResourceCost) &&
            (identical(other.castingConditions, castingConditions) ||
                other.castingConditions == castingConditions) &&
            (identical(other.targetAndAreaType, targetAndAreaType) ||
                other.targetAndAreaType == targetAndAreaType) &&
            (identical(other.areaSizeUnits, areaSizeUnits) ||
                other.areaSizeUnits == areaSizeUnits) &&
            (identical(other.area, area) || other.area == area) &&
            (identical(other.distanceType, distanceType) ||
                other.distanceType == distanceType) &&
            (identical(other.distance, distance) ||
                other.distance == distance) &&
            (identical(other.durationType, durationType) ||
                other.durationType == durationType) &&
            (identical(other.duration, duration) ||
                other.duration == duration) &&
            (identical(other.actionType, actionType) ||
                other.actionType == actionType) &&
            (identical(other.savingThrow, savingThrow) ||
                other.savingThrow == savingThrow) &&
            (identical(other.damage, damage) || other.damage == damage) &&
            (identical(other.damageType, damageType) ||
                other.damageType == damageType) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.classes, classes) || other.classes == classes) &&
            (identical(other.subClasses, subClasses) ||
                other.subClasses == subClasses) &&
            (identical(other.source, source) || other.source == source));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        name,
        level,
        school,
        isVerbal,
        isSomatic,
        isMaterial,
        materialComponents,
        castingTime,
        castingResource,
        castingResourceCost,
        castingConditions,
        targetAndAreaType,
        areaSizeUnits,
        area,
        distanceType,
        distance,
        durationType,
        duration,
        actionType,
        savingThrow,
        damage,
        damageType,
        description,
        classes,
        subClasses,
        source
      ]);

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SpellsDataImplCopyWith<_$SpellsDataImpl> get copyWith =>
      __$$SpellsDataImplCopyWithImpl<_$SpellsDataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SpellsDataImplToJson(
      this,
    );
  }
}

abstract class _SpellsData implements SpellsData {
  const factory _SpellsData(
      {final String name,
      final int? level,
      final MagicScools? school,
      final bool? isVerbal,
      final bool? isSomatic,
      final bool? isMaterial,
      final String? materialComponents,
      final int? castingTime,
      final CastingResource? castingResource,
      final int? castingResourceCost,
      final String? castingConditions,
      final TargetOrAreaType? targetAndAreaType,
      final AreaSizeUnits? areaSizeUnits,
      final int? area,
      final DistanceType? distanceType,
      final int? distance,
      final DurationType? durationType,
      final int? duration,
      final ActionType? actionType,
      final Attributes? savingThrow,
      final String? damage,
      final DamageTypes? damageType,
      final String? description,
      final ClassData? classes,
      final String? subClasses,
      final String? source}) = _$SpellsDataImpl;

  factory _SpellsData.fromJson(Map<String, dynamic> json) =
      _$SpellsDataImpl.fromJson;

  @override
  String get name;
  @override
  int? get level;
  @override
  MagicScools? get school;
  @override
  bool? get isVerbal;
  @override
  bool? get isSomatic;
  @override
  bool? get isMaterial;
  @override
  String? get materialComponents;
  @override
  int? get castingTime;
  @override
  CastingResource? get castingResource;
  @override
  int? get castingResourceCost;
  @override
  String? get castingConditions;
  @override
  TargetOrAreaType? get targetAndAreaType;
  @override
  AreaSizeUnits? get areaSizeUnits;
  @override
  int? get area;
  @override
  DistanceType? get distanceType;
  @override
  int? get distance;
  @override
  DurationType? get durationType;
  @override
  int? get duration;
  @override
  ActionType? get actionType;
  @override
  Attributes? get savingThrow;
  @override
  String? get damage;
  @override
  DamageTypes? get damageType;
  @override
  String? get description;
  @override
  ClassData? get classes;
  @override
  String? get subClasses;
  @override
  String? get source;

  /// Create a copy of SpellsData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SpellsDataImplCopyWith<_$SpellsDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
